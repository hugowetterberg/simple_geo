<?php
// $Id$

define('SIMPLE_GEO_PAIR_SEPARATOR', ',');
define('SIMPLE_GEO_COORDINATE_SEPARATOR', ' ');

require('includes/simple_geo_themeable_functions.php');

/**
 * Implementation of hook_menu
 *
 * @return void
 **/
function simple_geo_menu() {
  $items = array();
  $items['node/%node/map'] = array(
    'title' => t('Map'),
    'page callback' => 'simple_geo_view_position',
    'page arguments' => array(1),
    'access callback' => 'node_access',
    'access arguments' => array('view', 1),
    'type' => MENU_CALLBACK,
    'file' => 'includes/simple_geo_fallback_functions.php',
    'weight' => 0,
  );
  return $items;
}

/**
 * Implementation of hook_perm
 *
 * @return array
 **/
function simple_geo_perm() {
  return array(
    'edit own nodes area', 'edit own nodes position', 'edit all areas', 'edit all positions'
  );
}

/**
 * Unimplemented.
 *
 * This method will provide mechanisms for guessing positions
 *
 **/
function simple_geo_guess_position($node) {
  return '';
}

/**
 * Implementation of hook_form_alter
 *
 * @return void
 **/
function simple_geo_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'node_type_form') {
    $type = $form['#node_type']->type;
    $set = array(
      '#type' => 'fieldset',
      '#title' => t('Geographic fields'),
      '#collapsible' => TRUE);
    
    $set['allow_position'] = array(
      '#type' => 'checkbox',
      '#default_value' => variable_get('allow_position_'. $type, FALSE),
      '#title' => t('Use position'),
    );
    
    $set['allow_area'] = array(
      '#type' => 'checkbox',
      '#default_value' => variable_get('allow_area_'. $type, FALSE),
      '#title' => t('Use area'),
    );
    
    $form['simple_geo'] = $set;
  }
  else if ($form['#id'] == 'node-form'){
    $node = $form['#node'];
    global $user;
    
    if ($form_id == $node->type .'_node_form') {
      $allow_position = variable_get('allow_position_'. $node->type, FALSE);
      $allow_area = variable_get('allow_area_'. $node->type, FALSE);
      
      $set = array(
        '#type' => 'fieldset',
        '#attributes' => array('id'=>'simple_geo_form'),
        '#title' => t('Position'),
        '#collapsible' => TRUE);
      $editing = FALSE;

      if (module_exists('content')) {
        $set['#weight'] = content_extra_field_weight($form['type']['#value'], 'simple_geo');
      }

      if ($allow_position && (user_access('edit all positions') || 
          ($node->uid == $user->uid && user_access('edit own node position')))) {
        if (!isset($node->simple_geo_position)) {
          $position = simple_geo_guess_position($node);
        }
        else {
          $position = $node->simple_geo_position;
        }

        $set['simple_geo_position'] = array(
          '#type' => 'textfield',
          '#title' => t('Position'),
          '#attributes' => array('class'=>'simple-geo-position'),
          '#default_value' => $position,
          '#weight' => 1,
        );
        
        $editing = true;
      }
      
      if ($allow_area && (user_access('edit all areas') || 
          ($node->uid == $user->uid && user_access('edit own node area')))) {
        $area = '';
        if (isset($node->simple_geo_area)) {
          $area = $node->simple_geo_area;
        }
        
        $set['simple_geo_area'] = array(
          '#type' => 'textarea',
          '#title' => t('Area'),
          '#attributes' => array('class'=>'simple-geo-area'),
          '#default_value' => $area,
          '#weight' => 2,
        );
        
        $editing = true;
      }
      
      if ($editing) {
        drupal_add_js(drupal_get_path('module', 'simple_geo') .'/js/node_edit.js', 'module', 'header');
        $set['map_placeholder'] = array(
          '#type' => 'markup',
          '#value' => '<div class="map-placeholder"></div>',
          '#weight' => -1,
        );
        $form['simple_geo'] = $set;
      }
    }
  }
}

/**
 * Implementation of hook_content_extra_fields.
 */
function simple_geo_content_extra_fields($type_name) {
  $extras = array();
  
  if (variable_get('allow_position_'. $type_name, FALSE) || variable_get('allow_area_'. $type_name, FALSE)) {
    $extra['simple_geo'] = array(
      'label' => t('Position'),
      'description' => t('Simple Geo module form.'),
      'weight' => 0,
    );
  }
    
  return $extra;
}

/**
 * Inplementation of hook_nodeapi
 *
 * @return mixed
 **/
function simple_geo_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  $allow_position = variable_get('allow_position_'. $node->type, FALSE);
  $allow_area = variable_get('allow_area_'. $node->type, FALSE);
  
  switch($op) {
    case 'delete':
      simple_geo_delete_position($node->nid);
      simple_geo_delete_area($node->nid);
      break;
    case 'update':
    case 'insert':
      global $user;
      
      if (!empty($node->simple_geo_position) && $allow_position && (user_access('edit all positions') || 
          ($node->uid == $user->uid && user_access('edit own node position')))) {
        simple_geo_set_position($node->nid, $node->simple_geo_position);
      }
      
      if (!empty($node->simple_geo_area) && $allow_area && (user_access('edit all areas') || 
          ($node->uid == $user->uid && user_access('edit own node area')))) {
        simple_geo_set_area($node->nid, $node->simple_geo_area);
      }
      
      simple_geo_update_cache($node->nid);
      break;
    case 'load':
      if ($allow_position) {
        $node->simple_geo_position = simple_geo_position($node->nid);
      }
      if ($allow_area) {
        $node->simple_geo_area = simple_geo_area($node->nid);
      }
      break;
    case 'view':
      $map_view = '';
      if (!empty($node->simple_geo_position)) {
        $coords = explode(' ', $node->simple_geo_position);
        $map_view .= '<div class="node-map"><a rel="map" title="'. 
          t('Map for @name', array('@name'=>$node->title)) .'" href="'. url('node/'. $node->nid .'/map/') .'">'. 
          t('Show on map') .'</a></div>';
        $map_view .= '<div class="geo"><span class="latitude">'. $coords[0] .'</span><span class="longitude">'. $coords[1] .'</span></div>';
      }
      
      if (!empty($node->simple_geo_area)) {
        $map_view .= '<script type="text/javascript">var node_'. $node->nid .'_position="'. $node->simple_geo_position .'";'.
          'var node_'. $node->nid .'_area="'. $node->simple_geo_area .'";</script>';
      }
      
      $node->content[] = array(
        '#weight' => 50,
        '#value' => $map_view,
      );
      
      break;
  }
}

/**
 * Gets the position of a node. 
 *
 * @param int $nid The id of the node
 *
 * @return string The point as a coordinate pair in the same format as WKT
 **/
function simple_geo_position($nid) {
  $res = db_query("SELECT AsText(position) FROM {simple_geo_position} WHERE nid = %d", $nid);
  if ($wkt = db_result($res)) {
    return simple_geo_clean_wkt('point', $wkt);
  }
}

/**
 * Gets the area of a node. 
 *
 * @param int $nid The id of the node
 *
 * @return string The vertexes of the polygon as coordinate pairs in the same format as WKT
 **/
function simple_geo_area($nid) {
  $res = db_query("SELECT AsText(area) FROM {simple_geo_area} WHERE nid = %d", $nid);
  if ($wkt = db_result($res)) {
    return simple_geo_clean_wkt('polygon', $wkt);
  }
}

/**
 * Updates the cache for the spatial relationship between points and polygons
 *
 * @param int $nid The node to update the cache for
 * @param string $op The cache type to update. 'area', 'point' or 'all', defaults to 'all'
 *
 * @return void
 **/
function simple_geo_update_cache($nid, $op='all') {
  $updates = array();
  
  if ($op=='all') {
    //Delete all cache entries
    db_query("DELETE FROM {simple_geo_in_area} WHERE point_nid = %d OR area_nid = %d", $nid, $nid);
  }
  
  //Refresh cache for position
  if ($op!='area') {
    if ($op!='all') {
      //Delete all position cache entries
      db_query("DELETE FROM {simple_geo_in_area} WHERE point_nid = %d", $nid);
    }
    $position = simple_geo_position($nid);
    if ($position) {
      $p_array = simple_geo_coordinates_to_array($position);
      $res = db_query("SELECT nid, AsText(area) as area_wkt 
        FROM {simple_geo_area}
        WHERE Contains(area, GeomFromText('%s'))", simple_geo_to_wkt('point', $position));
      $areas = array();
      while ($bb_match = db_fetch_object($res)) {
        $a_coords = simple_geo_clean_wkt('polygon', $bb_match->area_wkt);
        if (simple_geo_point_in_polygon($p_array, $a_coords)) {
          $updates[$nid] = $bb_match->nid;
        }
      }
    }
  }
  
  //Refresh cache for area
  if ($op!='point') {
    if ($op!='all') {
      //Delete all area cache entries
      db_query("DELETE FROM {simple_geo_in_area} WHERE area_nid = %d", $nid);
    }
    $area = simple_geo_area($nid);
    if ($area) {
      $a_array = simple_geo_coordinates_to_array($area);
      $res = db_query("SELECT nid, AsText(position) as position_wkt 
        FROM {simple_geo_position}
        WHERE Contains(GeomFromText('%s'), position)", simple_geo_to_wkt('polygon', $area));
      $points = array();
      while ($bb_match = db_fetch_object($res)) {
        $p_coords = simple_geo_clean_wkt('point', $bb_match->position_wkt);
        if (simple_geo_point_in_polygon($p_coords, $a_array)) {
          $updates[$bb_match->nid] = $nid;
        }
      }
    }
  }
  
  
  if(count($updates)) {
    //Add all new cache items
    $query = "INSERT INTO {simple_geo_in_area}(point_nid, area_nid) VALUES";
    foreach ($updates as $point => $area) {
      $query .= '('. $point .','. $area .'),';
    }
    db_query(trim($query,','));
    
    //Notify all modules of new spatial relationships
    $handlers = module_implements('simple_geo_inside');
    foreach ($updates as $point => $area) {
      foreach($handlers as $module) {
        call_user_func($module .'_simple_geo_inside', $point, $area);
      }
    }
  }
}

/**
 * Checks if a nodes point is inside a nodes area
 *
 * @param int $area_nid The nid of the area node
 * @param int $position_nid The nid of the position node
 *
 * @return void
 **/
function simple_geo_contains($area_nid, $position_nid) {
  $res = db_query("SELECT COUNT(*) FROM {simple_geo_in_area} WHERE point_nid=%d AND area_nid=%d", $position_nid, $area_nid);
  return db_result($res)==1;
}

/**
 * Function that returns the necessary information for integrating with the
 * position data table
 *
 * @return void
 **/
function simple_geo_position_db_info() {
  return array(
    'table' => 'simple_geo_position',
    'node' => 'nid',
    'geometry' => 'position',
  );
}

/**
 * Function that returns the necessary information for integrating with the
 * area data table
 *
 * @return void
 **/
function simple_geo_area_db_info() {
  return array(
    'table' => 'simple_geo_area',
    'node' => 'nid',
    'geometry' => 'area',
  );
}

/**
 * Function that returns the necessary information for integrating with the
 * spatial relationship cache
 *
 * @return void
 **/
function simple_geo_cache_db_info() {
  return array(
    'table' => 'simple_geo_in_area',
    'position' => 'point_nid',
    'area' => 'area_nid',
  );
}

/**
 * Checks if a point is inside a polygon
 *
 * @param array $point An array containing lat & long or a WKT formatted string with a coordinate pair
 * @param array $point An array containing arrays of lat & long or a WKT formatted string with a coordinate pairs
 *
 * @return bool
 **/
function simple_geo_point_in_polygon($point, $polygon) {
  // Transform string coordinates into arrays with lat and long values
  if (!is_array($point)) {
    $point = simple_geo_coordinates_to_array($point);
  }
  $vertices = $polygon; 
  if (!is_array($vertices)) {
    $vertices = simple_geo_coordinates_to_array($vertices);
  }
  
  // Check if the point sits exactly on a vertex
  if (simple_geo_point_on_vertex($point, $vertices) == true) {
    return true;
  }
  
  // Check if the point is inside the polygon or on the boundary
  $intersections = 0; 
  $vertices_count = count($vertices);
  
  for ($i=1; $i < $vertices_count; $i++) {
    $vertex1 = $vertices[$i-1]; 
    $vertex2 = $vertices[$i];
    if ($vertex1[1] == $vertex2[1] 
        and $vertex1[1] == $point[1] 
        and $point[0] > min($vertex1[0], $vertex2[0]) 
        and $point[0] < max($vertex1[0], $vertex2[0])) { // Check if point is on an horizontal polygon boundary
      return true;
    }
    if ($point[1] > min($vertex1[1], $vertex2[1]) 
        and $point[1] <= max($vertex1[1], $vertex2[1]) 
        and $point[0] <= max($vertex1[0], $vertex2[0]) 
        and $vertex1[1] != $vertex2[1]) { 
      $xinters = ($point[1] - $vertex1[1]) * ($vertex2[0] - $vertex1[0]) / ($vertex2[1] - $vertex1[1]) + $vertex1[0]; 
      
      if ($xinters == $point[0]) { // Check if point is on the polygon boundary (other than horizontal)
        return true;
      }
      if ($vertex1[0] == $vertex2[0] || $point[0] <= $xinters) {
        $intersections++; 
      }
    } 
  } 
  // If the number of edges we passed through is even, then it's in the polygon. 
  if ($intersections % 2 != 0) {
    return true;
  } else {
    return false;
  }
}

/**
 * Helper function for simple_geo_point_in_polygon that checks
 * if a point is on a vertex
 *
 * @return bool
 **/
function simple_geo_point_on_vertex($point, $vertices) {
  foreach($vertices as $vertex) {
    if ($point == $vertex) {
      return true;
    }
  }
}

/**
 * Deletes the position of a node
 *
 * Does NOT update the cache
 * see simple_geo_update_cache for updating the cache
 *
 * @return void
 **/
function simple_geo_delete_position($nid) {
  db_query("DELETE FROM {simple_geo_position} WHERE nid = %d", $nid);
}

/**
 * Deletes the area of a node
 *
 * Does NOT update the cache
 * see simple_geo_update_cache for updating the cache
 * 
 * @return void
 **/
function simple_geo_delete_area($nid) {
  db_query("DELETE FROM {simple_geo_area} WHERE nid = %d", $nid);
}

/**
 * Sets the position of a node
 *
 * Does NOT update the cache
 * see simple_geo_update_cache for updating the cache
 *
 * @return void
 **/
function simple_geo_set_position($nid, $position) {
  simple_geo_delete_position($nid);
  db_query("INSERT INTO {simple_geo_position}(nid, position)
    VALUES(%d, GeomFromText('%s'))", $nid, simple_geo_to_wkt('point', $position));
}

/**
 * Sets the area of a node
 *
 * Does NOT update the cache
 * see simple_geo_update_cache for updating the cache
 *
 * @return void
 **/
function simple_geo_set_area($nid, $area) {
  simple_geo_delete_area($nid);
  db_query("INSERT INTO {simple_geo_area}(nid, area)
    VALUES(%d, GeomFromText('%s'))", $nid, simple_geo_to_wkt('polygon', $area));
}


/**
 * Constructs a WKT-string for points and polygons
 *
 * @param string $type The WKT-type to construct, 'point', 'polygon' or 'linestring'
 * @param string $coord The coodinate string with coordinates and pairs separated according to the WKT standard
 *
 * @return string The WKT-string
 **/
function simple_geo_to_wkt($type, $coord) {
  switch($type) {
    case 'point':
      return 'POINT('. $coord .')';
    case 'polygon':
      return 'POLYGON(('. $coord .'))';
    case 'linestring':
      return 'LINESTRING('. $coord .')';
  }
}

/**
 * Takes a of with coordinates in the WKT-format and
 * and returns them as an array.
 *
 * If the string only contains a single coordinate pair
 * an array with lat,long will be returned. Otherwise 
 * an array containing arrays for each coordinate pair
 * will be returned.
 *
 * @return void
 **/
function simple_geo_coordinates_to_array($coords) {
  $pairs = explode(',', $coords);
  $pair_count = count($pairs);
  for($i=0; $i<$pair_count; $i++) {
    $pairs[$i] = explode(' ',$pairs[$i]);
  }
  if ($pair_count==1) {
    return $pairs[0];
  }
  else {
    return $pairs;
  }
}

/**
 * Helper function that takes a string with WKT 
 * formatted coordinate pairs and changes it to
 * use other separators.
 *
 * @return string The reformatted coordinate pairs
 **/
function simple_geo_custom_separators($coords, $pair=SIMPLE_GEO_PAIR_SEPARATOR, $coordinate=SIMPLE_GEO_COORDINATE_SEPARATOR) {
  //No change required
  if ($pair==SIMPLE_GEO_PAIR_SEPARATOR && $coordinate==SIMPLE_GEO_COORDINATE_SEPARATOR) {
    return $coords;
  }
  
  //Map separators to temporary tokens to avoid mixup of separator types
  $coords = str_replace(SIMPLE_GEO_PAIR_SEPARATOR, '#P', $coords);
  $coords = str_replace(SIMPLE_GEO_COORDINATE_SEPARATOR, '#C', $coords);
  
  //Return the string with the new separators
  return str_replace('#P',$pair,str_replace('#C',$coordinate,$coords));
}

/**
 * Removes WKT geometry type information to return a
 * clean string containing the coordinate pairs
 *
 * @param $type The type of the WKT string. 'point' or 'polygon'
 * @param $type The WKT-representation of a geometry
 *
 * @return string The coordinate pairs
 **/
function simple_geo_clean_wkt($type, $wkt) {
  switch($type) {
    case 'point':
      return preg_replace('/^POINT\((.+)\)$/', '$1', $wkt);
    case 'polygon':
      return preg_replace('/^POLYGON\(\((.+)\)\)$/', '$1', $wkt);
  }
}